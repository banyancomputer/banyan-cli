use anyhow::Result;
use jwalk::{DirEntryIter, WalkDirGeneric};
use std::cmp::Ordering;
use std::path::PathBuf;
use tokio_stream::{Iter, StreamMap};

pub fn spider(
    input_dirs: Vec<PathBuf>,
    follow_links: bool,
    scratch_dir: PathBuf,
    // TODO (laudiacay): this type is heinous! make it better somehow...
) -> Result<StreamMap<(PathBuf, PathBuf), Iter<DirEntryIter<(u64, Option<u64>)>>>> {
    // Declare a stream map that will hold all the futures for copying and operating on the files
    let mut map = StreamMap::new();
    // Iterate over all the input directories
    for path_root in input_dirs {
        // Canonicalize the path
        let path_root = path_root
            .canonicalize()
            .expect("could not canonicalize path");

        // TODO (laudiacay) : Is this necessary?
        // Generate a random prefix for input DIR
        let new_root = scratch_dir.join(format!("{:x}", rand::random::<u64>()));
        // Add the mapping from the original prefix to the new prefix to the final output
        // TODO: We need to change how we are finalizing the output of the program. For now keep this struct.
        // final_output
        //     .original_prefix_to_final_prefix
        //     .push((path_root.clone(), new_root.clone()));

        // TODO (laudiacay): Is this really necessary? Look into jwalk plz
        // Walk the contents of the input directory and copy them to the scratch directory
        let walk_dir = WalkDirGeneric::<(u64, Option<u64>)>::new(path_root.clone())
            // Only follow symlinks if the user specified it
            .follow_links(follow_links)
            // Process the contents of the directory in parallel
            .process_read_dir(|_depth, _path, read_dir_state, children| {
                // Read the first child of the directory
                if let Some(Ok(dir_entry)) = children.first_mut() {
                    // If this is a file than tally the size of the file to the read_dir_state
                    if dir_entry.file_type().is_file() {
                        // Get the size of the file
                        let file_size = dir_entry.metadata().unwrap().len();
                        // Add the size of the file to the read_dir_state
                        *read_dir_state += file_size;
                        // Not sure what this does
                        dir_entry.client_state = Some(file_size);
                    }
                };
                // Sort the children of the directory by size
                children.sort_by(|a, b| match (a, b) {
                    (Ok(a), Ok(b)) => a.file_name.cmp(&b.file_name),
                    (Ok(_), Err(_)) => Ordering::Less,
                    (Err(_), Ok(_)) => Ordering::Greater,
                    (Err(_), Err(_)) => Ordering::Equal,
                });
            });
        // TODO (laudiacay): make sure handoff from jwalk to tokio is efficient
        // Hand of the iterator generated by WalkDirGeneric to tokio. This turns the iterator into a stream
        let directory_stream: tokio_stream::Iter<DirEntryIter<(u64, Option<u64>)>> =
            tokio_stream::iter(walk_dir);
        // Insert the stream into the stream map
        map.insert((path_root, new_root), directory_stream);
    }
    Ok(map)
}
