use crate::types::spider::SpiderMetadata;
use anyhow::Result;
use jwalk::WalkDir;
use std::path::Path;

/// Walks the input directory and returns a list of all the files and directories in it.
/// # Arguments
/// * `input_dir` - The path to the directory to be walked.
/// * `follow_links` - Whether or not to follow symlinks. (currently not supported)
/// # Returns
/// A `Result`, which can either succeed or fail. If it succeeds, it returns a vector of SpiderMetadata. If it fails, it returns an error.
// TODO (organizedgrime): add support for following symlinks
pub async fn spider(input_dir: &Path, _follow_links: bool) -> Result<Vec<SpiderMetadata>> {
    // Canonicalize the path
    let path_root = input_dir.canonicalize()?;

    // Walk the contents of the input directory and get a list of them
    let walk_dir = WalkDir::new(&path_root)
        // Only follow symlinks if the user specified it
        // TODO support symlinks- right now we are NOT doing this. document this decision!
        .follow_links(false)
        // Process the contents of the directory in parallel
        .process_read_dir(|_depth, _path, _read_dir_state, _children| ());

    // TODO (laudiacay): make sure handoff from jwalk to tokio is efficient
    // Hand off the iterator generated by WalkDirGeneric to tokio. This turns the iterator into a stream
    walk_dir
        .into_iter()
        .map(move |item| {
            item.map(|entry| SpiderMetadata::new(&path_root, entry))
                .map_err(|e| e.into())
        })
        .collect()
}
