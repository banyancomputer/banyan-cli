use crate::types::{pipeline::PackPipelinePlan, spider::SpiderMetadata};
use anyhow::Result;
use jwalk::WalkDir;
use std::{
    collections::HashSet,
    fs,
    path::{Path, PathBuf},
    sync::Arc,
};

/// Walks the input directory and returns a list of all the files and directories in it.
/// # Arguments
/// * `input_dir` - The path to the directory to be walked.
/// * `follow_links` - Whether or not to follow symlinks. (currently not supported)
/// # Returns
/// A `Result`, which can either succeed or fail. If it succeeds, it returns a vector of SpiderMetadata. If it fails, it returns an error.
// TODO (organizedgrime): add support for following symlinks
pub async fn spider(
    input_dir: &Path,
    _follow_links: bool,
    seen_files: &mut HashSet<PathBuf>,
) -> Result<Vec<PackPipelinePlan>> {
    // Canonicalize the path
    let path_root = input_dir.canonicalize()?;

    // Walk the contents of the input directory and get a list of them
    let walk_dir = WalkDir::new(&path_root)
        // Only follow symlinks if the user specified it
        // TODO support symlinks- right now we are NOT doing this. document this decision!
        .follow_links(false)
        // Process the contents of the directory in parallel
        .process_read_dir(|_depth, _path, _read_dir_state, _children| ());

    let mut packing_plan = vec![];

    // TODO (laudiacay): make sure handoff from jwalk to tokio is efficient
    // Hand off the iterator generated by WalkDirGeneric to tokio. This turns the iterator into a stream
    let spidered: Vec<SpiderMetadata> = walk_dir
        .into_iter()
        .map(move |item| {
            item.map(|entry| SpiderMetadata::new(&path_root, entry))
                .map_err(|e| e.into())
        })
        .collect::<Result<Vec<SpiderMetadata>>>()?;

    for spidered in spidered.into_iter() {
        // If this is a duplicate
        if seen_files.contains(&spidered.canonicalized_path.to_path_buf()) {
            // Just skip it
            continue;
        }
        // Now that we've checked for duplicates, add this to the seen files
        seen_files.insert(spidered.canonicalized_path.clone());

        // Construct Automatic Reference Counting pointer to the spidered metadata
        let origin_data = Arc::new(spidered.clone());
        // If this is a directory
        if spidered.original_metadata.is_dir() {
            // Push a PackPipelinePlan with this origin data
            packing_plan.push(PackPipelinePlan::Directory(origin_data));
        }
        // If this is a symlink
        else if spidered.original_metadata.is_symlink() {
            // Determine where this symlink points to, an operation that should never fail
            let symlink_target = fs::read_link(&spidered.canonicalized_path).unwrap();
            // Push a PackPipelinePlan with this origin data and symlink
            packing_plan.push(PackPipelinePlan::Symlink(origin_data, symlink_target));
        }
        // If this is a file that was not in a group
        else {
            // Push a PackPipelinePlanÂ using fake file group of singular spidered metadata
            packing_plan.push(PackPipelinePlan::FileGroup(vec![origin_data]));
        }
    }
    Ok(packing_plan)
}

/// Converts a PathBuf into a vector of path segments for use in WNFS.
pub fn path_to_segments(path: &Path) -> Result<Vec<String>> {
    let path = path
        .to_path_buf()
        .into_os_string()
        .into_string()
        .map_err(|_| wnfs::error::FsError::InvalidPath)?;
    let path_segments: Vec<String> = path
        .split('/')
        .filter(|s| !s.is_empty())
        .map(|s| s.to_string())
        .collect();

    // if path_segments.len() == 1 {
    //     let mut tmp = vec!["".to_string()];
    //     tmp.extend(path_segments);
    //     path_segments = tmp;
    // }

    Ok(path_segments)
}
